解析命令行指令及参数

一、getopt()函数
1.头文件：unistd.h/getopt.h

2.原型：int getopt(int argc, char * const argv[], const char *optstring);

3.参数：argc、argv为main函数参数，optstring为指定要解析的指令选项
optstring格式："vha:b::c"
其中每一个字母为一个短选项(-v、-h、-a、-b、-c)
字母后面1个:代表该选项需要参数，运行格式为-a100或-a 100
2个:代表参数为可选（可带可不带），运行格式只能为-b200，
没有:代表不需要参数

4.四个全局变量：char* optarg、int optind、int opterr、int optopt
optarg：若选项后面有参数，则optarg指向该参数
optind：循环使用getopt()函数扫描短选项时，为"下一个"选项在argv中的下标；扫描结束后，为第一个非选项参数的argv下标
例如：./out -h 10 -v 1 2   getopt扫描到-h时，optind为3，指向-v，所有选项扫描结束后，optind为5
opterr：出现不可识别的选项时，getopt将打印错误信息。将opterr设为0不打印错误信息
optopt：存放不可识别的选项至optopt

5.返回值：返回选项的字母的ascii值，解析完毕返回-1

6.用法：while((opt=getopt())!=-1)
switch(opt)……

7.解析过程：getopt首先扫描argv[1]到argv[argc-1]，并将选项及参数依次放到argv数组的最左边，非选项参数依次放到argv的最后边，即该函数会改变argv的排列顺序。

二、getopt_long()函数
1.原型：int getopt_long(int argc, char * const argv[],const char *optstring, const struct option *longopts,int *longindex);
2.参数：
longopts：结构体option的数组，每个结构体对应一个长选项（--version）
longindex：一般赋为NULL；否则，它指向一个变量，这个变量在扫描选项的过程中会被赋值为寻找到的长选项在longopts
中的索引值
3.struct option {
　　const char *name;
　　int has_arg;
　　int *flag;
　　int val;
};
name为长选项的名字，如version、help
has_arg为长选项是否有参数，no_argument=0,required_argument=1,optional_argument=2,为了可读性一般使用符号常量
无参数：--version
需要参数：--size=100或--size 100
可选参数：--strides=10
flag ：如果该指针为NULL，那么getopt_long返回val的值；如果该指针不为NULL，那么会使得它所指向的变量填入val的值，同时getopt_long返回0；
val ：如果flag是NULL，那么val通常是个字符常量，否则为指定填入flag的值

eg:
static const struct option longopts[]={
    {"version", no_argument, NULL, 'v'},
    {"size", required_argument, NULL, 's'},
    {"resize", optional_argument, NULL, 'r'}
    {NULL, 0, NULL, 0},    // 注意这个结构体必须有
}
5.getopt_long()兼容getopt(),即短选项仍然可以识别、optarg、optind、opterr、optopt也仍然可用
